 \documentclass[conference]{IEEEtran}

\IEEEoverridecommandlockouts
% Add the compsoc option for Computer Society conferences.
%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[conference]{../sty/IEEEtran}


\usepackage{listings}
\usepackage{url}
\usepackage{graphicx}
\usepackage{numprint}
\usepackage{array,multirow}
\usepackage{multicol}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage[autostyle]{csquotes}



\newtheorem{rem}{Remark}
\newtheorem{example}{Example}
% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/tex-archive/macros/latex/contrib/oberdiek/
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.






% *** CITATION PACKAGES ***
%
%\usepackage{cite}
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 4.0 (2003-05-27) and later if using hyperref.sty. cite.sty does
% not currently provide for hyperlinked citations.
% The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/cite/
% The documentation is contained in the cite.sty file itself.






% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
  % \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/graphics/
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found as epslatex.ps or
% epslatex.pdf at: http://www.ctan.org/tex-archive/info/
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex





% *** MATH PACKAGES ***
%
%\usepackage[cmex10]{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics. If using
% it, be sure to load this package with the cmex10 option to ensure that
% only type 1 fonts will utilized at all point sizes. Without this option,
% it is possible that some math symbols, particularly those within
% footnotes, will be rendered in bitmap form which will result in a
% document that can not be IEEE Xplore compliant!
%
% Also, note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/





% *** SPECIALIZED LIST PACKAGES ***
%
%\usepackage{algorithmic}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithms/
% There is also a support site at:
% http://algorithms.berlios.de/index.html
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithmicx/




% *** ALIGNMENT PACKAGES ***
%
%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/


%\usepackage{mdwmath}
%\usepackage{mdwtab}
% Also highly recommended is Mark Wooding's extremely powerful MDW tools,
% especially mdwmath.sty and mdwtab.sty which are used to format equations
% and tables, respectively. The MDWtools set is already installed on most
% LaTeX systems. The lastest version and documentation is available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/mdwtools/


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.


%\usepackage{eqparbox}
% Also of notable interest is Scott Pakin's eqparbox package for creating
% (automatically sized) equal width boxes - aka "natural width parboxes".
% Available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/eqparbox/





% *** SUBFIGURE PACKAGES ***
%\usepackage[tight,footnotesize]{subfigure}
% subfigure.sty was written by Steven Douglas Cochran. This package makes it
% easy to put subfigures in your figures. e.g., "Figure 1a and 1b". For IEEE
% work, it is a good idea to load it with the tight package option to reduce
% the amount of white space around the subfigures. subfigure.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at:
% http://www.ctan.org/tex-archive/obsolete/macros/latex/contrib/subfigure/
% subfigure.sty has been superceeded by subfig.sty.



%\usepackage[caption=false]{caption}
%\usepackage[font=footnotesize]{subfig}
% subfig.sty, also written by Steven Douglas Cochran, is the modern
% replacement for subfigure.sty. However, subfig.sty requires and
% automatically loads Axel Sommerfeldt's caption.sty which will override
% IEEEtran.cls handling of captions and this will result in nonIEEE style
% figure/table captions. To prevent this problem, be sure and preload
% caption.sty with its "caption=false" package option. This is will preserve
% IEEEtran.cls handing of captions. Version 1.3 (2005/06/28) and later
% (recommended due to many improvements over 1.2) of subfig.sty supports
% the caption=false option directly:
%\usepackage[caption=false,font=footnotesize]{subfig}
%
% The latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/subfig/
% The latest version and documentation of caption.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/caption/




% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure. The latest version and documentation can be found at:
% http://www.ctan.org/tex-archive/macros/latex/base/



%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/sttools/
% Documentation is contained in the stfloats.sty comments as well as in the
% presfull.pdf file. Do not use the stfloats baselinefloat ability as IEEE
% does not allow \baselineskip to stretch. Authors submitting work to the
% IEEE should note that IEEE rarely uses double column equations and
% that authors should try to avoid such use. Do not be tempted to use the
% cuted.sty or midfloat.sty packages (also by Sigitas Tolusis) as IEEE does
% not format its papers in such ways.





% *** PDF, URL AND HYPERLINK PACKAGES ***
%
%\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/misc/
% Read the url.sty source comments for usage information. Basically,
% \url{my_url_here}.


% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )


% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}

\def \ICSTW {2017 IEEE Eighth International Conference on Software Testing, Verification and Validation Workshops (ICSTW)}
\def \TAICPART {10th Testing: Academic and Industrial Conference - Practice and Research Techniques (TAIC PART)}
\def \SECTEST {6th International Workshop on Security Testing (SECTEST 2015)}
\def \MUTATION {10th International Workshop on Mutation Analysis (Mutation 2015)}
\def \IWCT {Submitted for publication to 6th International Workshop on Combinatorial Testing (IWCT 2017)}
\def \INSTA {2nd International Workshop on Software Test Architecture (InSTA 2015)}
\def \AMOST {12th Workshop on Advances in Model Based Testing (A-MOST 2015)}
\def \ASQT {13th User Symposium on Software Quality, Test and Innovation (ASQT 2015)}

\def \UScopyright {U.S. Government work not protected by U.S. copyright}
\def \UKcopyright {978-1-4799-1885-0/15/\$31.00 \copyright 2015 Crown}
\def \EUcopyright {978-1-4799-1885-0/15/\$31.00 \copyright 2015 European Union}
\def \IEEEcopyright {978-1-4799-1885-0/15/\$31.00 \copyright 2015 IEEE}

\newcommand{\copyrights}[2]{%
\renewcommand{\thefootnote}{}%
\footnotetext{\ICSTW \\ #1 \\ #2}
\renewcommand{\thefootnote}{\arabic{footnote}}%
}

\usepackage{color}
\newcommand{\todo}[1]{}
\renewcommand{\todo}[1]{{\color{red} TODO: {#1}}}

\begin{document}


\title{Crazy title}


\author{\IEEEauthorblockN{Murat Ozcan}
\IEEEauthorblockA{Siemens Building Technologies CPS Software Hub\\
Chicago, USA\\
murat.ozcan@siemens.com}
}

\maketitle


\begin{abstract}
The overall purpose of this study is to describe the new paradigms achieved in testing,
in lieu of the transition of applications from the desktop, to web and to cloud. 
We study the Siemens Building Technologies Horizon Cloud Program,
where products are enabled by the Horizon ecosystem with a focus on speed, independence and small complexity.
Horizon Cloud provides widespread connectivity to legacy \& new controls, 3rd party, IoT, 
edge devices and a step-wise covering of on-site, real-time requirements. 
Horizon Cloud features its own apps based on building integration framework, along with themes, with an open API for ecosystem and SSP. 
The program also provides a common data model and API to BT Building Integration Framework to map southbound data against model.

We start by describing the architecture of the Horizon Cloud program; the components that make up the whole, how they relate, 
technologies being used in each layer and how they are being tested individually and as a whole. 	

We continue by describing the continuous delivery process; Dockerization of the continuous integration pipeline,
the architectural components being built as Docker images and being run as Docker containers, being deployed and tested in the cloud at unit, API and UI levels. 
Later, we describe how the components that make the architecture are orchestrated in AWS hosted OpenShift. 

We describe the abstraction and the structure of the test code, the page object model, 
how specifications are separated from the page object / service / logic layer and the test data. 

Finally, we analyze three applications of combinatorial testing (CT) in this modern development environment,
incorporating the CT model into automation using BDD style Protractor end to end UI tests. 
We go through the CT modeling process using newly released, open source, cloud based CTWedge: Combinatorial Testing Web-based Editor and Generator. 
We describe how the model translates into functions in the code and its utilization in behavioral driven tests.

Finally, we analyze a scenario where a sequence of actions are incorporated into a CT model;
with a focus on verification of these sequences, compositions of the actions and streamlining the expected assertions,
in line, per the data-manipulated test oracle.

\end{abstract}



\begin{IEEEkeywords}
Combinatorial testing, Input parameter model, Sequence, Angular, Protractor, UI automation
\end{IEEEkeywords}



\todo{ Add comments from Rcik 
Rick : A number of things I think would be of particular interest. 
One would be your comments on how CT fits into container/Docker development and some of the other platforms that are used a lot today. 
Most researchers don’t know a lot about modern development environments, so your experience and recommendations on how to use CT for these would be very valuable, e.g., 
what sort of extra tooling would be helpful, characteristics that are good or poor fits for existing CT tools.

Also of interest is the way you integrate covering arrays and sequence testing.
This is something that isn’t always handled well, and yet very important for an awful lot of applications.
The measurements of coverage at the end of the presentation are also of interest,
in particular how to use coverage to determine when it’s cost effective to complete testing.
}


\section{Introduction}
Modern web development typically falls into a design pattern. In the front-end there can be a JavaScript (JS) framework, some popular ones being Angular, React and Vue.
The back-end preferences are varied, there is a plethora of choices in language : JS (NodeJS), GoLang, Python, C\#, Java to name a few. 
This is coupled by a database, examples include MySQL, MongoDB, Elasticsearch.

Previous to cloud technologies, such an application would be hosted on a dedicated web server, or a hosting company.
In contrast, cloud computing adopts a concept called “virtualization,” where hardware resources can be further optimized through software functionality.
As a result, not only application performance is optimized but also hosting the application is more cost effective.

A challenge for cloud computing is the resource intensive operating system (OS) usage, where the size of the OS image can be in gigabytes while the application is much smaller. 
Consequently virtual machines, sinfce they have to host an OS, do not solve this problem.
Containerization is one proposed solution, and Docker is one example of a program that performs operating-system-level virtualization. 
\todo {insert Docker reference}
In containerization, a layer between OS and applications is introduced to optimize resource usage and eliminate the need for an OS.

This is highly valuable for application development because it enables the application be hosted in a minimal, resource and cost effective "container" which 
allows the application to be built, deployed and tested faster. Throughout the paper we will refer to this paradigm as Cloud Computing.

In this paper, we will study how Combinatorial Testing (CT) fits in the front-end test automation and continuous deployment of cloud computing paradigm.
Examples will include modeling of the input parameter model (IPM), how the model translates to fields and methods in page objects \todo{insert reference}, 
and the utilization of it all in behavioral driven test specifications.
One example will include a scenario where a sequence of actions will be incorporated into a CT model, a problem that has been addressed in a variety of ways in previous works.

\section{Related Work}

	\subsection{Introduction to Combinatorial Testing}
	\todo{@Ludwig: small intro to CT}.

	\subsection{Previous works on sequences}
	The method of modeling sequenced parameter groups applied in this paper borrows ideas from a combination of the modeling patterns found in \cite{segall2012common}.
	These modeling patterns include: 
	\begin{enumerate}
		\item \textit{Optional and conditionally-excluded values:} the use of N/A value for parameters that are not a part of the parameter group in the current sequence.
		\item \textit{Ranges and boundaries:} the reduction of parameter values for certain parameters with over 100 possibilities
		\item	\textit{Multi-selection \& Order and padding:} a variation of these ideas was used for control parameters which enable/disable the parameter groups per the sequence.
	\end{enumerate}

	\subsection{Previous works on page objects}
	There has been hundreds of papers on BACnet since early 90s. 
	While many papers have touched on testing. Generally, the testing of Event Enrollment Objects has not been a topic of focus.
	To get a better understanding on BACnet and Event Enrollment, some of the previous work can be reviewed in \cite{bushby1997bacnettm}, \cite{bushby2002bacnet}, \cite{nussbaumerbacnet} and \cite{newman2015bacnet}. 
	
	\subsection{Previous works on cloud computing}
	There has been hundreds of papers on BACnet since early 90s. 
	While many papers have touched on testing. Generally, the testing of Event Enrollment Objects has not been a topic of focus.
	To get a better understanding on BACnet and Event Enrollment, some of the previous work can be reviewed in \cite{bushby1997bacnettm}, \cite{bushby2002bacnet}, \cite{nussbaumerbacnet} and \cite{newman2015bacnet}. 


% \subsection{Description of SBA-Method}
%   In \cite{kampel2017combinatorial} a combinatorial methodology to model composed software systems is presented.
% 	The main idea behind this methodology is to combine legacy test suites of components of an SUT,
% 	via a so called \emph{meta-array}, to get a test suite for the whole SUT.
% 	It is also shown that, if the legacy test suites, as well as the meta-array fulfill certain combinatorial criteria,
% 	so does the test suite for the whole SUT (for details see \cite{kampel2017combinatorial}.)
% 	The generation of a combinatorial test suite for an SUT with the \todo{to be defined in into to CT:} IPM $(v_1,\ldots,v_g)$ can be described as follows:
% 	\begin{itemize}
%     \item [] \textit{Step 1}: Partition the given parameter configuration $(v_1,\ldots,v_g)$ into classes $V_1,\ldots,V_k$.
%     \item [] \textit{Step 2}: For each $i=1,\ldots,k$ construct legacy test suites that are covering arrays of a certain strength $t$:
% 		$S_i=\mathit{MCA}(N_i;t,|V_i|,V_i)$.
%     \item [] \textit{Step 3}: Construct a meta array $\mathcal M = \mathit{MCA}(N_m;t,k,(N_1,\ldots,N_k))$.
%     \item [] \textit{Step 4}: For all columns of $\mathcal M$ do the following:
% 		in column $j$ of $\mathcal M$ replace all occurrences of $n$ with the $n$-th row of $\mathcal S_j$.
% 		%Apply the plug-in construction to the seed arrays $(S_i)_{i=1}^k$ and the meta array $\mathcal M$.
% \end{itemize}
% The result of this construction is again a covering array of strength $t$.

\section{The System Under Test}

	\subsection{Description of the Architecture}
	
	Horizon Cloud program is composed of many teams and microservice architectural applications.
	The application / system under test in this study will be Building Operator IC (BOIC).
	BOIC is used for \todo {describe BOIC , also insert what IC means} . BOI is being development by the Chicago team at Siemens Software Hub. 

	Figure~\ref{fig:BOIC architecture} represents the BOIC architecture.
	The front-end is an Angular framework, in TypeScript.
	The back-end is an ExpressJS application on top of NodeJS platform. 
	At the time of this study, there is an effort to move some of this functionality to other microservices - implemented in GoLang (Go) - to reduce operating costs.
	The Protocol Adapter (in C\#) and Gateway (in NodeJS and Java) serve the purpose of exposing Siemens or third party edge-devices to the cloud. 
	This enables the hardware and the gateway at a customer site to be controlled from a web browser, anywhere in the globe.

\begin{figure}[!h]
		\includegraphics[width=0.70\textwidth,]{architecture.pdf}
	\caption{BOIC architecture}
	\label{fig:BOIC architecture}
\end{figure}

	\subsection{Description of the Continuous Deployment Environment }
	In a traditional configuration management scenario, there may be a plethora of servers needed for web development activities.
	Staging, committing, packaging the developed code, testing at each stage, source controlling and finally publishing at production server(s) may take place on a number of machines.
	This can end up in high costs of operation and maintenance in order to enable development activities.

	In cloud computing, utilizing containerization, each one of these development activities can be operated in a docker container.
	Figure~\ref{fig:UIpipeline} shows the GitLab pipeline for the UI component developed in Angular.
	GitLab is a continuous integration tool that supports the teams by hosting code repositories (similar to GitHub), providing defect tracking, enabling code reviews and continuous integration support. 
	Another example of a continuous integration tool is Jenkins, which can serve the same purpose thorough is extensions.

	\begin{figure*}[!ht]
		\centering
			\includegraphics[width=1.00\textwidth]{UIpipeline.pdf}
		\caption{UI component pipeline}
		\label{fig:UIpipeline}
	\end{figure*}
	

	The team uses Git for source control. \todo{about git}. 
	When any code is submitted, the application is built in a docker container, OSS Clearing for licensing is executed, unit testing and linting are done, the application is deployed to an cloud-hosted container and automated UI tests are run targeting the deployment.
	If testing passes, the code can get merged to the master branch. 
	This automated testing process ensures that after any code commit, the application is tested end to end and the quality is ensured. 
	To give a sense of scale, at the time of writing, the front end is over 15k lines of TypeScript code in Angular, over 1k lines of unit tests in Karma, over 4k lines of end to end (e2e) UI tests Protractor. 
	There are over 200 unit tests that execute in seconds, over 300 e2e UI tests that execute under 10 minutes. 



\subsection{Description of the Test Code Structure}

	\subsubsection{Page Object Pattern}

	Released in 2011, Angular is popular front-end JavaScript framework for designing dynamic web applications.
	It is maintained by Google with the help of the open source community.
	It recommends the use of Microsoft's TypeScript language, which introduces class-based object oriented programming, static typing and generics. \todo{refer to wiki}.

	Components are the building blocks of Angular applications and they easily nest inside each other.
	Each component may have its own class, html and css file. This structure provides a way to design dynamic web applications while keeping the front-end code clean. 

	Page object pattern is a popular UI test automation design pattern in the industry. \todo{refer to Fowler and selenium paper}.
	In Fowler's proposed terminology, we refer to web pages as 'pages' and Angular components as 'panels'.
	Each panel is a class. A page can be made up of many panels, which have a class-based object oriented structure.   

	Designing the test automation architecture, it became clear that it would not only be straightforward but also efficient to replicate the structure of Angular components in page objects as pictured in Figure~\ref{fig:angular}.
	One advantage of this is easier maintenance of the automation code as the development code changes.
	The other advantage is its benefits with asynchronous test execution.

	In a panel object, the element selectors become the fields and the methods become test actions within the component / panel. 
	TypeScript is a superset of JavaScript. It complies into JavaScript and includes the latest EcmaScript features \todo{reference to EcmaScript} .
	The latest EcmaScript features allow developers to write sequential looking asynchronous code.

	With regards to test automation this means clean code that executes as fast as the environment allows, resistant to flakey tests and stale elements on the page. 
	This is because the page components load with panel-object-classes simultaneously, while the page element selectors get instantiated.
	We plan to study this design pattern in a future paper. For the purpose of the current study, it is sufficient to understand that all test relevant methods are housed in classes that represent panel objects / Angular components.
	
	\begin{figure}[!h]
		\includegraphics[width=0.45\textwidth,]{angular.pdf}
	\caption{Angular components as page and panel objects}
	\label{fig:angular}
	\end{figure}

	\subsubsection{Test data}
	The test data is stored in JSON files. This allows parameterization of test inputs, input-driven tests, as well as ease of maintenance as the UI changes.
	Another perk of using JSON is being able to convert test suites generated with CT tools - ex: ACTS, CTWedge \todo{references }- from csv format to JSON format.

	\subsubsection{Test Specifications}

	\begin{figure*}[!ht]
		\centering
			\includegraphics[width=1.00\textwidth]{codeSample.pdf}
		\caption{Protractor test code sample in State-based, Behavior-driven Acceptance format}
		\label{fig:codeSample}
	\end{figure*}	


	\begin{figure}[!h]
		\includegraphics[width=0.60\textwidth,]{stateBasedScenario.pdf}
		\caption{State-based, Behavior-driven Acceptance Scenario}
		\label{fig:stateBasedScenario}
	\end{figure}
	
	The team uses Protractor test framework, which is the default end-to-end test framework for Angular applications. \todo{insert reference}
	It runs tests against application running in a real browser, interacting with it as a user would.
	It combines technologies from Selenium webDriver, NodeJS and allows tests to be described in a BDD format -\textit{Given, When, Then}-, describing the overall behavior of a system at a low level.
	
	The tests specifications are stored in Protractor spec files written in TypeScript. 
	The aforementioned benefits of the technology stack allow developers in test to write clean, simple, synchronous looking asynchronous code, without hard-waits or sleeps, resistant to stale elements and flakey tests.

	Over time during our development, the test specification came to be described in State-based, Behavior-driven Acceptance Scenarios \todo{reference blog post}. 
	Generally, these are in the format:


	\begin{itemize}
		\item [] \textit{Given I have arrived in some state} 
		\item [] \textit{When I trigger a particular event} 
		\item [] \textit{Then the application conducts an action}
		\item [] \textit{And the application moves to another state}
	\end{itemize}

	It was found out that this style of expression is not only descriptive at a meta level, but also maps well to the page object pattern.
	Figure~\ref{fig:codeSample} and Figure~\ref{fig:stateBasedScenario} show an a Protractor test spec sample with a state-based, behavior-driven acceptance scenario.
	As observed from the sample code, \textit{tunnelPage} class / page-object is utilized for:
	
	\begin{itemize}
		\item [] - setup, using the \textit{setDropDown()} class method. 
		\item [] - test action, using the \textit{startButton} class field.
		\item [] - test assertion, verifying that \textit{tunnelConnectionStateText} class field / selector shows the correct text.
	\end{itemize}

	The code also samples the Protractor BDD style where a test workflow scenario is covered. 
	The \textit{it} block is one test in the workflow, the \textit{describe} block houses more tests / \textit{it} blocks that lead to the completion of the workflow - not shown in this example for the sake of simplicity.
	







\section{Test Methodology}
	
	In the following sections the coverage measurements, the pro's and con's of the IBM and the SBA methods will be evaluated. 
		
	
	\subsection{Input driven testing of hardware}
	
	Considering t-way coverage measurement, SBA method provides evidence of the measurement while coverage measurement in IBM method is inconsequential as explained in the previous section. 
		
	Regarding the Application of the methods, IBM method is straightforward once the constraints are figured out. 
	SBA method has elaborate steps as outlined in section III D. 
	In step 3 of the method (plug-in construction), there is a need for a script that replaces integers with real values.
	Currently a freely available tool does not exist for such a task.
	
	Constraints are important for both methods, but they are vital for IBM method. 
	They can be manageable in a small scale, yet as the SUT gets larger they get more complicated. 
	Figure~\ref{fig:constraintsIBM-UH} shows the Javascipt code for constraints used in the IBM method.
	
% can we put this picture on the same page as the section?	
%\begin{figure*}[!bth]
%	\centering
%		\includegraphics[width=.90\textwidth]{constraintsIBM-UH.pdf}
%	\caption{Constraints in JavaScript, IBM method}
%	\label{fig:constraintsIBM-UH}
%\end{figure*}

	Considering the above factors, IBM method may be preferred for smaller systems under test while SBA method may be preferred for larger systems.
	However, the significance of the above factors for the system and/or the test team may effect the preferences for the method of use.

	\subsection{Filtering Points by Tag Combinations }

	\subsection{State Transitions Between Combinations of Alarm Data, With a Variable Oracle}

	\subsection{Sequenced Filtering, Searching, Sorting of Geo-located Sites}
	
\section{Conclusion and future work}
	
The initial challenge in this study was how to best test EEO configurations in the most efficient manner.
During the study it became apparent that the methods applied can be used to test any system where the parameter groups for
the Combinatorial Input Parameter Model (IPM) are not simultaneously available, and instead may appear sequentially.
Future work on this front may incorporate system test ideas where each seed (in the SBA method) or different color (in the IBM method) being a different module of functionality.

\textbf{Acknowledgments.}
This research was carried out in the context of Austrian COMET K1
program and publicly funded by the Austrian Research Promotion Agency
(FFG) and the Vienna Business Agency (WAW).

\bibliographystyle{IEEEtran}
\bibliography{cloud}

\end{document}
